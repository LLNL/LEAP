\documentclass[11pt]{article}
\usepackage{amssymb, latexsym, amsmath, amsthm, amsfonts, verbatim, bm}%, txfonts
\usepackage[final]{graphicx}
\usepackage{pst-all}
\usepackage{pst-plot, pst-node, pst-bar, pst-3dplot, pstricks-add}
%\usepackage{bm}

\title{LEAP Technical Manual \\ Version 1.0}
\author{Kyle Champley}
\date{\today}

\setlength{\topmargin}{1.0cm} \setlength{\textheight}{24cm} \setlength{\textwidth}{16cm}
\setlength{\oddsidemargin}{1.0cm} \setlength{\evensidemargin}{1.0cm} \setlength{\hoffset}{-1.0cm}
\setlength{\voffset}{-3.0cm}
\hfuzz2pt

\begin{document}

\newcommand{\B}[1]{\textbf{#1}}
\newcommand{\ra}{\rightarrow}
\newcommand{\sinc}{\text{sinc}}
\newcommand{\supp}{\text{supp}}
\newcommand{\suppe}{\text{supp}_{\varepsilon}}
\newcommand{\ind}{\B{1}}
\newcommand{\sgn}{\text{sgn}}
\newcommand{\etal}{\text{et al. }}
\newcommand{\Beta}{{\boldsymbol\beta}}
\newcommand{\Radon}{\mathcal{R}}
\newcommand{\Xray}{\mathcal{P}}
\newcommand{\Fourier}{\mathcal{F}}
\newcommand{\Hilbert}{\mathcal{H}}
\newcommand{\Identity}{\mathcal{I}}
\newcommand{\BL}{\mathcal{L}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\Cov}{\text{Cov}}
\newcommand{\argmin}{\operatorname{argmin}}

\maketitle


\definecolor{aclr}{RGB}{32,178,170}

\section{Introduction}

This document serves as a technical description of the algorithms in LivermorE AI Projector (LEAP) library.  LEAP is a C/C++/CUDA library of tomographic projectors (forward and back projection) implemented for both multi-GPU and multi-core CPU. We provide bindings to PyTorch to achieve differentiable forward and backward projectors for AI/ML-driven Computed Tomography (CT) applications.

Our projectors are implemented for the standard 3D CT geometry types: parallel-, fan-, and cone-beam with axial or helical source trajectory. These geometry types accommodate shifts of the detectors and non-uniform angular spacing. Cartoonized sketches of these CT geometry types is shown in Figure \ref{fig:geometrySketches}. For added flexibility, we also provide a flexible modular-beam format where the user may specify the location and orientation of every source and detector pair. All projectors use the Separable Footprint method [Long, Fessler, and Balter, TMI, 2010] which provides a matched projector pair that models the finite size of the voxel and detector pixel. These matched projectors ensure convergence and provide accurate, smooth results. Unmatched projectors or those projectors that do not model the finite size of the voxel or detector pixel may produce artifacts when used over enough iterations [DeMan and Basu, PMB, 2004].

\begin{figure}[h]
\begin{tabular}{ccc}
parallel-beam & fan-beam & cone-beam \\
\includegraphics[scale=0.33]{parallelBeam}
& \includegraphics[scale=0.35]{fanBeam}
& \includegraphics[scale=0.35]{coneBeam}
\end{tabular}
\caption{Cartoon sketches of the parallel-, fan-, and cone-beam geometries.} \label{fig:geometrySketches}
\end{figure}

We also provide projectors and analytic inversion algorithms, i.e., FBP, for a few specialized x-ray/Radon transforms:
\begin{enumerate}
\item Cylindrically-symmetric/anitsymmetric objects (related to the Abel Transform) in parallel- and cone-beam geometries with user-specified symmetry axis [Champley and Maddox, Optica, 2021]. These are often used in flash radiography applications.
\item Attenuated Radon Transform (ART) for parallel-beam geometries. These are used in parallel-hole collimator SPECT and Volumetric Additive Manufacturing (VAM).
\end{enumerate}

In addition to the projectors, we also provide a few other algorithms for tomographic imaging, including:
\begin{enumerate}
\item Quantitatively-accurate analytic inversion algorithms, i.e., Filtered Backprojection (FBP) for each geometry except modular-beam.
\item A GPU implementation of 3D anisotropic Total Variation (TV) functional, gradient, and quadratic form to be used in regularized reconstruction.
\item Python implementations of some iterative reconstruction algorithms: OSEM, SART, ASD-POCS, and RWLS.
\end{enumerate}

The CPU- and GPU-based projectors are nearly identical (32-bit floating point precision) and are quantitatively accurate and thus can be used in conjuction with physics-based corrections, such as, scatter and beam hardening correction. If one is looking for a more general-purpose and full functioning CT software package (it does not, however, work with PyTorch and is closed-source), see LTT \cite{ChampleyLTT}.

\section{Software Architecture}

The majority of LEAP is written in C/C++/CUDA using the standard libraries.  The main class is called \textit{tomographicModels}.  All calls to LEAP must go through this class.  This class contains functions to call the projectors (forward projection and backprojection), FBP reconstruction algorithms, and noise filter functions.  It also contains a class called \textit{parameters} which contains all the CT geometry, CT volume parameters, and other run-time parameters.

There are two different interfaces to \textit{tomographicModels} class.  The first interface uses torch and PyTorch, so that LEAP can be used as differentiable projectors in ML/DL applications.  Installation of this interface is achieved with a pip install command.  The second interface uses standard ANSI C and a simple ctypes Python binding.  This interface is for those that want to use LEAP as a library of tomographic functions and want a version of LEAP that does not require torch/PyTorch.  Installation of this interface is achieved with cmake.  Installation instructions are given in the github wiki page.  A diagram of the LEAP software architecture is shown in Figure \ref{fig:LEAParchitecture}.

\begin{figure}[h!]
\psset{unit=0.5mm}
\pspicture(-150,-40)(50,50)%
\rput[c](-35,35){\psshadowbox[fillcolor=lightgray]{\;\, \quad leaptorch \quad \;}}
\rput[c](35,35){\psshadowbox[fillcolor=lightgray]{\, \quad leapctypes \quad \,}}
\rput[c](-35,20){\psshadowbox{Torch C Interface}}
\rput[c](35,20){\psshadowbox{ANSI C Interface}}
\pspolygon[shadow=true](-68, -40)(68, -40)(68, 10)(-68, 10)
\rput(0,0){tomographicModels}
\rput[c](-30,-15){\psshadowbox{parameters}}
\rput[c](30,-15){\psshadowbox{projectors}}
\rput[c](-32,-30){\psshadowbox{FBP}}
\rput[c](30,-30){\psshadowbox{filters}}
\endpspicture
\caption{Overview of LEAP software architecture.  The gray boxes are Python and the white boxes are C/C++/CUDA.} \label{fig:LEAParchitecture}
\end{figure}

\section{Troubleshooting Tools}

LEAP has a fair amount of parameters to specify and its algorithms are complex.  To assist users in troubleshooting, we have developed several tools.  The first tool simply prints all the parameter settings to the screen.  The function is given by
\begin{itemize}
    \item[] printParameters().
\end{itemize}
The second tool builds a 3D sketch (using matplotlib) of the CT geometry and the CT volume.  This sketch can be generated by
\begin{itemize}
    \item[] sketchSystem().
\end{itemize}
Example of the output of this function with a helical cone-beam geometry is shown in Figure \ref{fig:helicalSketch} and a modular-beam geometry is shown in Figure \ref{fig:modularBeamSketch}.

\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{helical}
\end{center}
\vspace{-20pt}\caption{Sketch of a helical cone-beam geometry generated with the \textit{sketchSystem()} Python function.  The  magenta box is the reconstruction volume, the gray rectangle is the detector panel, the green dots are the source positions, and the red lines trace from the source to each of the four corners of the detector.} \label{fig:helicalSketch}
\end{figure}

\section{LEAP Parameters and General Syntax}

LEAP is a library of CT algorithms that operates on data arrays provided by the user.  These data arrays are the projection data and the volume data (see Section \ref{sec:dataArrays}).  The only permanent memory that LEAP manages itself is a class with member variables that parameterize the CT geometry and CT volume.  Some temporary memory is allocated during the computation of an algorithm but it is destroyed before the completion of the algorithm.  Prior to running any algorithm in LEAP, one must first set the CT geometry parameters and the CT volume parameters.

\subsection{Setting the CT Geometry Parameters}

Setting the CT geometry parameters is done by running one of the functions below
\begin{itemize}
\item[] set\_parallelBeam(numAngles, numRows, numCols, pixelHeight, pixelWidth, centerRow, centerCol, phis)
\item[] set\_fanBeam(numAngles, numRows, numCols, pixelHeight, pixelWidth, centerRow, centerCol, phis, sod, sdd, tau=0.0)
\item[] set\_coneBeam(numAngles, numRows, numCols, pixelHeight, pixelWidth, centerRow, centerCol, phis, sod, sdd, tau=0.0, helicalPitch=0.0)
\item[] set\_modularBeam(numAngles, numRows, numCols, pixelHeight, pixelWidth, sourcePositions, detectorCenters, rowVecs, colVecs)
\end{itemize}
A description of these parameters can be found in Tables \ref{tab:stdGeometryParameters} and \ref{tab:modularParameters}.  The helical pitch is in units of mm/radian.  One can also set the normalized helical pitch (unitless) with the following function
\begin{itemize}
    \item[] set\_normalizedHelicalPitch(normalized helical pitch).
\end{itemize}
The helical pitch, $\Delta$, and the normalized helical pitch $\widehat{\Delta}$ are related by
\begin{eqnarray*}
\widehat{\Delta} &:=& 2\pi \frac{\Delta}{\text{numRows} * \text{pixelHeight} * \frac{\text{sod}}{\text{sdd}}}.
\end{eqnarray*}

\begin{table}[h!]
\caption{Parallel-, fan-, and cone-beam parameters.  Note that sod, sdd, and tau only apply to fan- and cone-beam geometries and helicalPitch only applies to cone-beam. The centerRow parameter has no effect on parallel- and fan-beam geometries.  Note that the phis parameter values \textit{must} be monotomic.  Internally, LEAP maintains a copy of the phis array, so if you want to make changes to it, you must either re-specify all parameters or use the \textit{set\_angles} function.  More information can be found in Section \ref{sec:CTGeometries}.} \label{tab:stdGeometryParameters}
\begin{tabular}{l|l|p{9cm}}
Parameter Name & Type & Description \\
\hline
numAngles & int32 & number of projection angles \\
numRows & int32 & number of detector rows \\
numCols & int32 & number of detector columns \\
pixelHeight & float32 & detector pixel pitch between rows (mm) \\
pixelWidth & float32 & detector pixel pitch between columns (mm) \\
centerRow & float32 & detector pixel row index for the ray that passes from the source, through the origin, and hits the detector \\
centerCol & float32 & detector pixel column index for the ray that passes from the source, through the origin, and hits the detector \\
phis & float32 array & array of the projection angles (degrees) \\
sod & float32 & source to object distance (mm) \\
sdd & float32 & source to detector distance (mm) \\
tau & float32 & horizontal translation of the rotation stage (mm) \\
helicalPitch & float32 & helical pitch (mm/radian)
\end{tabular}
\end{table}

\begin{table}[h!]
\caption{Modular-beam parameters.  Internally, LEAP maintains copies of sourcePositions, detectorCenters, rowVecs, and colVecs, so if you want to make changes to these, you must re-specify the modular-beam parameters.  More information can be found in Section \ref{sec:CTGeometries}.} \label{tab:modularParameters}
\begin{tabular}{l|l|p{9cm}}
Parameter Name & Type & Description \\
\hline
numAngles & int32 & number of projection angles \\
numRows & int32 & number of detector rows \\
numCols & int32 & number of detector columns \\
pixelHeight & float32 & detector pixel pitch between rows (mm) \\
pixelWidth & float32 & detector pixel pitch between columns (mm) \\
sourcePositions & float32 array & numAngles $\times$ 3 array of (x,y,z) coordinates of each source position \\
detectorCenters & float32 array & numAngles $\times$ 3 array of (x,y,z) coordinates of each detector center position \\
rowVecs & float32 array & numAngles $\times$ 3 array of vectors pointing in the positive detector row direction \\
colVecs & float32 array & numAngles $\times$ 3 array of vectors pointing in the positive detector row direction
\end{tabular}
\end{table}

To use the cylindrically-symmetric projectors, one must set the \textit{axisOfSymmetry} parameter.  This is done using the following function
\begin{itemize}
    \item[] set\_axisOfSymmetry(angleInDegrees)
\end{itemize}
which must be a number between -30 and 30 degrees.  This axis of symmetry is nominally the z-axis.  The \textit{axisOfSymmetry} parameter specifies the angle of rotation of the axis of symmetry around the x-axis.  One must specify numAngles = 1 for this to work.

The Attenuated Radon Transform (ART) is used to model parallel-hole SPECT data and its adjoint can be used as a model in Volumetric Additive Manufacturing (VAM).  In  these contexts, the \textit{CT volume} in LEAP, plays the role as the activity concentration in units of Bq/mm$^3$.  To use the ART projectors, one must set the attenuation map and the CT geometry must be parallel-beam.  One can either specify this map as a voxelized volume (which must be defined on the same voxel grid as the standard volume and its units are in inverse length, e.g., mm$^{-1}$) or as a constant-valued function defined on a cylinder.  One can use the follow two functions to set this attenuation map.
\begin{itemize}
    \item[] set\_attenuationMap(3D array)
    \item[] set\_cylindircalAttenuationMap(attenuationCoefficient, attenuationRadius)
\end{itemize}
If using the second of these two functions, the attenuationCoefficient must be floating point number whose units are in inverse length (e.g., mm$^{-1}$) and the attenuationRadius must be a floating point number listed in length units (e.g., mm).  Only GPU projectors are defined for the arbitrary attenuation map.  The constant-valued attenuation map work for both CPU and GPU processing and is much faster.  Analytic inversion algorithms are carried out via Novikov's formula and must have at least 360 degrees of angular coverage.

\subsection{Setting the CT Volume Parameters}

Next, the user should specify the CT volume parameters.  This can be done in one of the two following ways:
\begin{itemize}
\item[] set\_volume(numX, numY, numZ, voxelWidth, voxelHeight, offsetX, offsetY, offsetZ)
\item[] set\_defaultVolume()
\end{itemize}
Using the set\_defaultVolume() function (after the CT geometry parameters are set) sets the CT volume parameters to fill the field of view of the CT system with the nominal voxel sizes.  A description of these parameters can be found in Table \ref{tab:volumeParameters}.

\begin{table}[h!]
\caption{CT volume parameters.  A full description of these parameters can be found in Section \ref{sec:VolumeParameterization}.} \label{tab:volumeParameters}
\begin{tabular}{l|l|p{9cm}}
Parameter Name & Type & Description \\
\hline
numX & int32 & number of voxels in the x-dimension \\
numY & int32 & number of voxels in the y-dimension \\
numZ & int32 & number of voxels in the z-dimension \\
voxelWidth & float32 & voxel pitch (size) in the x and y dimensions (mm) \\
voxelHeight & float32 & voxel pitch (size) in the z dimension (mm) \\
offsetX & float32 & shift the volume in the x-dimension (mm) \\
offsetY & float32 & shift the volume in the y-dimension (mm) \\
offsetZ & float32 & shift the volume in the z-dimension (mm)
\end{tabular}
\end{table}

\subsection{Layout of the Data Arrays} \label{sec:dataArrays}

The data arrays must be contiguous.  The order of the projection data indices is listed as follows
\begin{eqnarray*}
\text{projection\_data}[\text{iAngle*numRows*numCols + iRow*numCols + iCol}],
\end{eqnarray*}
where iAngle, iRow, and iCol are the indices of the angle, row, and column dimensions.  The volume data can be in ZYX or XYZ order.  The ZYX order is the default setting.  To switch to the XYZ ordering do: set\_volumeDimensionOrder(0).  The ZYX ordering works best for GPU processing (and is \textit{required} for multi-GPU processing) and the XYZ ordering works best for CPU processing.  To be clear the ZYX ordering is as follows
\begin{eqnarray*}
\text{volume\_data}[\text{iZ*numY*numX + iY*numX + iX}]
\end{eqnarray*}
and the XYZ ordering is as follows
\begin{eqnarray*}
\text{volume\_data}[\text{iX*numY*numZ + iY*numZ + iZ}],
\end{eqnarray*}
where iX, iY, and iZ are the indices of the x, y, and z dimensions.  To help assist users in allocating contiguous arrays in the correct order in Python we provide the follow Python functions
\begin{itemize}
    \item[] allocateProjections()
    \item[] allocateVolume()
\end{itemize}

\section{CPU/GPU Processing}

As stated above, the algorithm in LEAP are written for both multi-GPU and multi-core CPU processing.  If one has at least one GPU, then GPU is the default processing.

There is an integer array parameter in LEAP where you specify which GPUs you would like to use.  This parameter can be set with the function
\begin{eqnarray*}
    \text{set\_GPUs}(\text{list of integers}).
\end{eqnarray*}
GPUs are listed on a computer as integers start at zero.  The first number in this list is considered the primary GPU.  For small computations it is advantageous to only use one GPU and not transfer any data on/off this GPU.  Thus if the data is already on the GPU, LEAP will only use this GPU for processing.  On the other hand, if the data is on the CPU memory, then the data will be transferred to each GPU in your list, the computation is carried out and then the result is copied back to the CPU array you specified.

For convenience, we also provide the function: set\_GPU(gpu index) to only set a single GPU.  To switch to CPU processing, run this command: set\_GPU(-1).

\section{A Note on Coordinate Systems}

LEAP uses the standard right-hand coordinate system, but there are important subtleties in CT coordinate systems so we thought we'd start off by describing these.  Typical two-dimensional Cartesian coordinate systems have the positive x-coordinate pointing to the right and the positive y-coordinate pointing up.  On the other hand, typical digital image coordinates have the column coordinate pointing to the right and the row coordinate pointing \textit{down}.  This discrepancy between digital image coordinates and Cartesian coordinates causes endless confusion.  Images are displaced on a computer screen this way and digital x-ray detectors record data this way as well.  Thus, in LEAP, we make the effort to use the digital image coordinate system as well as we can.

Thus, we define detector coordinates as digital image coordinates with the origin at the top-left side of the image/detector.  So that out Cartesian coordinates more closely match this convention, our z-axis shall be parallel to the detector row coordinate (and point in the same direction) and our x-axis shall be parallel to the detector column coordinate (and point in the same direction).  The y-axis shall be oriented to make a right-hand coordinate system.  A sketch of these coordinates in the cone-beam geometry is shown in Figure \ref{fig:coneBeamSketch}.

\begin{figure}[h]
\input{coneBeamSketch.tex}
\caption{LEAP provides forward and backprojectors and FBP reconstruction algorithms for a flexible cone-beam geometry.  Note that $(i,j)$ are detector column and row index coordinates, respectively, and $i_c = \text{centerCol}$ and $j_c = \text{centerRow}$.} \label{fig:coneBeamSketch}
\end{figure}

\section{CT Geometries} \label{sec:CTGeometries}

In this section we discuss the parameterization of the four LEAP scanner geometry types: parallel-, fan-, cone-, and modular-beam.  Cartoon sketches of the parallel-, fan-, and cone-beam geometries is shown in Figure \ref{fig:geometrySketches} and a detailed sketch of the cone-beam coordinates in Figure \ref{fig:coneBeamSketch}.  Except for the modular beam data set, we also give the mathematical expressions that link sets of parameterizations, state conjugate ray expressions, and the adjoint of the forward projection operators which are often refered to as backprojection operators.  Unless otherwise stated, all LEAP algorithms can be applied to any scanner geometry type.  This feature is made possible by the fact that data for all geometry types can be stored in contiguous 3D arrays (view number, detector row, detector column) and that most of the differences can be encapsulated in the implementation of the forward and back projectors.  Two-dimensional geometries can be achieved by setting the number of detector rows and number of z-slices to one.

\subsection{Detector Coordinates} \label{sec:DetectorCoordinates}

We denote detector coordinates by $(s,t)$.  The center position of the pixel coordinates are given by the following equations:
\begin{eqnarray*}
s[i] &=& \text{pixelWidth}*(i - \text{centerCol}), \text{ for } i = 0, \dots, \text{numCols}-1, \\
t[j] &=& \text{pixelHeight}*(j - \text{centerRow}), \text{ for } j = 0, \dots, \text{numRows}-1,
\end{eqnarray*}
where pixelWidth and pixelHeight are assumed to be in length units, e.g., mm or cm.  The indicies of the center detector column and center detector row are given by centerCol and centerRow, respectively.  For a perfectly centered detector, $\text{centerCol} = 0.5(\text{numCols}-1)$ and $\text{centerRow} = 0.5(\text{numRows}-1)$.

\subsection{Volume Parameterization} \label{sec:VolumeParameterization}

The location of the 3D voxels are specified by seven parameters as follows
\begin{eqnarray*}
x[i] &=& \text{voxelWidth}*(i - 0.5*(\text{numX}-1)) + \text{offsetX}, \text{ for } i = 0, \dots, \text{numX}-1, \\
y[j] &=& \text{voxelWidth}*(j - 0.5*(\text{numY}-1)) + \text{offsetY}, \text{ for } j = 0, \dots, \text{numY}-1, \\
z[k] &=& \text{voxelHeight}*(k - 0.5*(\text{numZ}-1)) + \text{offsetZ}, \text{ for } k = 0, \dots, \text{numZ}-1,
\end{eqnarray*}
where voxelWidth, voxelHeight, offsetX, offsetY, and offsetZ are assumed to be in length units, e.g., mm or cm.  Make sure that whatever units of length you choose that you stay consistent across all parameters.  The units of the voxelized volume (i.e., the reconstruction volume) are assumed to be in inverse length, e.g., mm$^{-1}$ or cm$^{-1}$.  We make this distinction because LEAP is fairly unique in it's quantitatively-accurate algorithms which we believe is very useful.

We note that there are some restrictions in the above volume parameters based on the CT geometry one is using.  These restrictions are listed below.
\begin{itemize}
\item parallel-beam
    \begin{itemize}
    \item voxelHeight must be equal to pixelHeight
    \item offsetZ must be zero
    \item numZ must be equal to numRows
    \end{itemize}
\item fan-beam
    \begin{itemize}
    \item voxelHeight must be equal to pixelHeight
    \item offsetZ must be zero
    \item numZ must be equal to numRows
    \end{itemize}
\item cone-beam
    \begin{itemize}
    \item no restrictions
    \end{itemize}
\item modular-beam
    \begin{itemize}
    \item voxelHeight must be equal to voxelWidth
    \end{itemize}
\end{itemize}
The restrictions for parallel- and fan-beam are that there is a one-to-one correspondence between the volume z-slices and the detector rows.  If any of the above restrictions are violated, then LEAP will return an error when a forward projection, backprojection, or FBP algorithm is called.

Besides the above restrictions, there are recommended values for the voxel sizes.  If the voxel size is significantly smaller or significantly bigger than these recommended sizes, then the LEAP algorithms may run much, much slower.

\begin{itemize}
\item parallel-beam
    \begin{itemize}
    \item recommend that voxelWidth be equal to pixelWidth
    \end{itemize}
\item fan-beam
    \begin{itemize}
    \item recommend that voxelWidth be equal to pixelWidth*sod/sdd
    \end{itemize}
\item cone-beam
    \begin{itemize}
    \item recommend that voxelWidth be equal to pixelWidth*sod/sdd
    \item recommend that voxelHeight be equal to pixelHeight*sod/sdd
    \end{itemize}
\item modular-beam
    \begin{itemize}
    \item recommend that voxelWidth be equal to pixelWidth/2
    \end{itemize}
\end{itemize}

It is recommended that one specify the volume parameters with the setDefaultVolume() command which sets the volume to fill the field of view of the CT system and use the recommended voxel sizes.

Note that the voxel samples are aligned with the x,y,and z axes and there are no methods to rotate these coordinates.  This restriction is for a few reasons.  First of all, there are certain rotations that are incompatible with Separable Footprint projectors.  Second, there are certain assumptions that one can leverage with standard CT geometry types (parallel, fan, and cone) that improve the computational efficiency of the projectors.  In fact, the complexity of the CT geometry is highly related to the computation speed of it projectors.  The speed of the projectors, listed from fasted to slowest, is: parallel-, fan-, cone-, and modular-beam.  And finally, it is easier to subdivide the volume into smaller chunk to process operations across multiple GPUs or to split it up into chunks that can fit into the GPU memory.  All of that being said, there are two \textit{tricks} to perform some rotations of the voxel coordinates.  First, for modular-beam coordinates, one may simply perform the inverse rotation on the location and orientation of the source locations and detector locations and orientations that will effectively rotate the volume coordinates.  Second, one may provide a phase shift of the provided projection angles which effectively rotates the volume coordinates around the z-axis.  Lastly, one may utilize the offsetX, offsetY, and offsetZ parameters to perform projections and backprojections of a single 2D plane or a single voxel at a time to generate a custom voxel grid.  This scheme, however, is less efficient and more difficult to manage.

In the next section we describe the integral transforms and inversion algorithms for parallel-, fan-, and cone-beam geometries.

\subsection{X-ray Transform and Its Adjoint}

Consider a linear operator denoted by $\mathcal{A}$.  Then its adjoint, usually denoted by $\mathcal{A}^*$, is defined such that $$<\mathcal{A}x, y> = <x, \mathcal{A}^*y>.$$  Note that if $\mathcal{A}$ where a real-valued matrix, its adjoint would be equal to its transpose.

The X-ray Transform of $f \in L^1(\mathbb{R}^3)$ is a linear operator given by
\begin{eqnarray*}
    Pf(\B{y}, \Theta) = \int_\mathbb{R} f(\B{y} + l\Theta) \, dl,
\end{eqnarray*}
where in general $y, \Theta \in \mathbb{R}^3$, but the exact specification of these parameters depends on the geometry of the CT system.  The X-ray Transform is often referred to as a \texit{projection} or \textit{forward projection} of a function.  While the adjoint of the X-ray Transform is commonly referred to as the \textit{backprojection} operator.  The backprojection operator usually takes the form of an integral over the various measured angles of the X-ray transform, but its exact form depends on the parameterization of the line integrals in the forward projection.

In the following, we shall make use of the following definitions
\begin{eqnarray*}
\theta &:=& \theta(\varphi) := \begin{bmatrix} \cos\varphi \\ \sin\varphi \\ 0 \end{bmatrix} \\
\theta^\perp &:=& \theta^\perp(\varphi) := \begin{bmatrix} -\sin\varphi \\ \cos\varphi \\ 0 \end{bmatrix}.
\end{eqnarray*}
We shall usually denote $g = Pf$.

\subsection{Parallel-Beam}

The X-ray transform and its adjoint in parallel-beam coordinates are given by 
\begin{eqnarray*}
Pf(s, \varphi, x_3) &:=& \int_\mathbb{R} f(s\bm{\theta}^\perp(\varphi) - l\bm{\theta}(\varphi) + x_3\B{e}_3) \, dl \\
P^*g(\bm{x}) &=& \int_0^{2\pi} g(\bm{x}\cdot\bm{\theta}^\perp(\varphi), \varphi, x_3) \, d\varphi
\end{eqnarray*}
Note that $g(s,\varphi) = g(-s,\varphi \pm \pi)$; the rays defined by these two coordinates are known are conjugate rays.

The object, $f$, can be reconstructed by
\begin{eqnarray*}
f(\bm{x}) &=& \frac{1}{4\pi} \int_0^{2\pi} \int_\mathbb{R} h(\bm{x}\cdot\bm{\theta}^\perp(\varphi) - s) g(s,\varphi, x_3) \, ds \, d\varphi.
\end{eqnarray*}
The discretization of the above equation is referred to as filtered backprojection (FBP).  The function $h$ is referred to as the ramp filter and is described in Section \ref{sec:rampFilter}.

% arctan(2*t*R/(R^2-t^2)) = 2*arcsin(t/sqrt(R^2+t^2))
\subsection{Fan-Beam}

\begin{comment}
\begin{figure}[h] % 626.5664, 1026.5664
\begin{center}
\psset{unit=1.1mm}
\begin{pspicture}(-60,-60)(63,65)
\psline[linewidth=1.25pt]{<->}(0,70)(0,0)(70,0)
\pscircle[linestyle=dashed](0,0){62.8558} \rput{90}(-62,0){\parbox{2.1 cm}{\large \B{source trajectory}}} % source trajectory
\rput{-22}(19,17){$R\bm{\theta}-l[\bm{\theta}$} % X-ray trajectory
\qdisk(-47.8405, 40.7694){3.5 pt} \rput(-50,45){\Large R$\bm{\theta}$} % source
%\psarc{->}(0, 0){65}{141}{150} % source trajectory
\psline[linestyle=dotted](-47.8405, 40.7694)(-3.5355,-3.5355)(21.2487,-28.3198) % line from source to detector
%\psline(21.9203, -28.9914)(19.0918, -31.8198)(21.9203, -34.6482) % perpendicular on detector
\psline[linestyle=dashed](-3.5355,-3.5355)(20,-3.5355) % line for angle start
\rput(-23,12){\Large $R$} % R
\rput(-0.5,-15){\Large $D-R$} % D
\psline[linestyle=dashed](-47.8405, 40.7694)(49.3427, 1.3120) % LOR
%\psarc[linewidth=1.5pt]{->}(-47.8405, 40.7694){102.65664}{-69}{-20} \rput{45}(26.4645,-33.5355){\large \B{detector}} \rput(50, 8){\Large $i$} % detector
\psline(-10,-60)(60, 10)
%\pscircle[linestyle=dotted](0,0){25} % FOV
\psarc[linecolor=blue]{->}(-3.5355,-3.5355){10}{0}{135} \rput(-5,9){\blue \Large $\beta$} % beta
\psarc[linecolor=blue]{->}(-47.8405, 40.7694){20}{-45}{-22} \rput(-29,28){\blue \Large $\alpha$} % alpha
\psline[linecolor=red](-3.5355,-3.5355)(7.2046, 18.4849) \rput(3.8,9.0){\red \Large $s$} % s
%\psarc[linecolor=red]{->}(-3.5355,-3.5355){18}{0}{64} \rput(13,8){\red \Large $\varphi$} % phi
%\psline(7.3366, 18.1587)(2.7969, 19.9929)(4.6311, 24.5326)
\psline(5.2319,14.4403)(0.7379,16.6322)(2.6010, 20.4521)
\qdisk(0,0){2.5pt} % center of rotation; origin
\psset{linecolor=aclr}\qdisk(-3.5355,-3.5355){2 pt}\psset{linecolor=black} % iso-center
\psline[linecolor=aclr,linewidth=1.5pt](0,0)(-3.5355,-3.5355) \rput(-0.25,-2.75){\Large \color{aclr} $\tau$} % tau
%\psline{<->}[linestyle=dashed](-53.8405, 34.7694)(18.7487,-37.8198) \rput(-13,-10){\Large $D$} % D
\rput(70,-3){\Large $x_1$} \rput(-3,68){\Large $x_2$}
\end{pspicture}
\caption{Fan-beam coordinates and their relation to parallel beam coordinates.  Note that the isocenter is indicated by a turquoise dot and the center of rotation is indicated by a black dot and is located at the origin.} \label{fig:fanBeam}
\end{center}
\end{figure}
\end{comment}

The X-ray transform and its adjoint in fan-beam coordinates (with linear detector) with center of rotation offset of $\tau$, source to object distance (sod) $R$, and source to detector distance $D$, are given by
\begin{eqnarray*}
Pf(u,\beta,x_3) &:=& \int_\mathbb{R} f\left(R\bm{\theta}(\beta) - \tau\bm{\theta}^\perp(\beta) - \frac{l}{\sqrt{1+u^2}}\left[\bm{\theta}(\beta) - u\bm{\theta}^\perp(\beta) \right] + x_3\B{e}_3 \right) \, dl \\
P^*g(\bm{x}) &=& \int \frac{1}{R-\bm{x}\cdot\bm{\theta}(\beta)} \sqrt{1 + u^2(\bm{x},\beta)} g\left( u(\bm{x},\beta), \beta, x_3\right) \, d\beta \\
u(\bm{x},\beta) &:=& \frac{\bm{x}\cdot \bm{\theta}^\perp(\beta) + \tau}{R - \bm{x}\cdot\bm{\theta}(\beta)}
\end{eqnarray*}
The parameter $u$ is the detector column coordinate divided by sdd and can be viewed as the slope of the ray in the xy plane.  Note the conjugate ray relation is $$g(u,\beta,x_3) = g\left(\frac{-u+\frac{2\tau R}{R^2-\tau^2} }{1 + u\left(\frac{2\tau R}{R^2-\tau^2}\right)}, \beta-2\tan^{-1}u + \tan^{-1}\left(\frac{2\tau R}{R^2-\tau^2}\right) \pm \pi, x_3 \right).$$

The object, $f$, can be reconstructed by the following Filtered Backprojection (FBP) algorithm
\begin{eqnarray*}
f(\bm{x}) &=& \frac{R}{2\pi} \int \frac{1}{(R-\bm{x}\cdot\bm{\theta}(\beta))^2} \int_\mathbb{R} h\left( u(\bm{x},\beta) - u \right) g(u, \beta, x_3) m(\tan^{-1}u,\beta) \frac{1 + \frac{\tau}{R}u}{\sqrt{1+u^2}} \, du \, d\beta.
\end{eqnarray*}
The function $m$ accounts for the number of redundant measurements for a particular angle and for an angular range of less than 360$^\circ$ it is often referred to as the \textit{Parker Weights}; See Section \ref{sec:ParkerWeighting}.  The function $h$ is referred to as the ramp filter and is described in Section \ref{sec:rampFilter}.

%\tan^{-1}\left(\frac{2\tau R}{R^2-\tau^2}\right)

Parallel-beam and fan-beam coordinates are related by the following transformations:
\begin{eqnarray*}
s &=& \frac{Ru-\tau}{\sqrt{1+u^2}}, \\
\varphi &=& \beta - \tan^{-1}u %\\
%\alpha &=& \tan^{-1}u.
\end{eqnarray*}
%where $R_{\tau} = \sqrt{R^2+\tau^2}$.

%Typically $R$ is referred to as the source-to-object distance (sod), $R_{\tau}$ is referred to as the source-to-object distance (sod), and $D$ is referred to as the source-to-detector distance (sdd).

%Let $i$ be the detector coordinate.  Then $u = \frac{i}{D}$ and $\alpha = \tan^{-1}\left(\frac{i}{D}\right)$.


\subsection{Cone-Beam}

The X-ray transform and its adjoint in cone-beam coordinates (with planar detector) with center of rotation offset of $\tau$ and source trajectory radius $R$ are given by
\begin{eqnarray*}
Pf(u,\beta,v) &:=& \int_\mathbb{R} f\left(R\bm{\theta}(\beta) - \tau\bm{\theta}^\perp(\beta) + \frac{l}{\sqrt{1+u^2+v^2}}\left[-\bm{\theta}(\beta)+u\bm{\theta}^\perp(\beta) + v\widehat{\bm{z}} \right] \right) \, dl \\
P^*g(\bm{x}) &=& \int \frac{\sqrt{1+ u^2(\bm{x},\beta) +v^2(\bm{x},\beta)}}{(R-\bm{x}\cdot\bm{\theta}(\beta))^2} g\left( u(\bm{x},\beta), \beta, v(\bm{x},\beta)\right) \, d\beta \\
u(\bm{x},\beta) &:=& \frac{\bm{x}\cdot \bm{\theta}^\perp(\beta) + \tau}{R - \bm{x}\cdot\bm{\theta}(\beta)} \\
v(\bm{x},\beta) &:=& \frac{x_3}{R - \bm{x}\cdot\bm{\theta}(\beta)}
\end{eqnarray*}
The parameter $v$ is the detector row coordinate divided by sdd and can be viewed as the slope of the ray.

The object, $f$, can be (approximately) reconstructed by the following Filtered Backprojection (FBP) algorithm
\begin{eqnarray*}
f(\bm{x}) &\approx& \frac{R}{2\pi} \int \frac{1}{(R-\bm{x}\cdot\bm{\theta}(\beta))^2} \\ &\times& \int_\mathbb{R} h(u(\bm{x},\beta) - u) g(u,\beta, v(\bm{x},\beta)) m(\tan^{-1}u,\beta) \frac{1+\frac{\tau}{R}u}{\sqrt{1+u^2+v^2(\bm{x},\beta)}} \, du \, d\beta.
\end{eqnarray*}
The function $h$ is referred to as the ramp filter and is described in Section \ref{sec:rampFilter}.

We would like to take a special note in the exact form of the adjoint of the cone-beam X-ray Transform.  Notice that
\begin{eqnarray*}
P^*g(\B{x}) &\neq& \int_\mathbb{R} g(u(\B{x},\beta), \beta, v(\B{x},\beta)) \, d\beta.
\end{eqnarray*}
The right hand side of the above equation is what many say is the backprojection operator, but this is false.  A backprojection is not always merely an integral over all the measured angles for those rays going through a specific point in space.  Thus it is also often said that FBP reconstruction of cone-beam data requires a \textit{weighted} backprojection because of the $\frac{1}{R-\B{x}\cdot\theta}$ term, but we see that this term is actually present in the backprojection already.  This origin of this term is the Jacobian of the change of coordinates matrix when deriving the backprojection.  One of the nice things about using match projector pairs, is that this weighting term is implicitly included when performing the backprojection operation.

\subsection{Parker Weighting} \label{sec:ParkerWeighting}

Define $\alpha := \tan^{-1}(u)$.  The function $m(\cdot, \cdot)$ given above is known as the Parker weighting function.  For a short scan, where $\pi + 2\alpha_{max} + \tan^{-1}\left(\frac{2\tau R}{R^2-\tau^2}\right) \leq \beta_{end}-\beta_0 < 2\pi$, it is given by
\begin{eqnarray*}
m(\alpha, \beta) &:=& \begin{cases} \sin^2\left( \frac{\pi}{4} \frac{\beta-\beta_0}{\alpha_{thres} - \alpha} \right), & 0 \leq \beta-\beta_0 < 2(\alpha_{thres}-\alpha), \\ 1, & 2(\alpha_{thres} - \alpha) \leq \beta-\beta_0 < \pi - 2\alpha - \tan^{-1}\left(\frac{2\tau R}{R^2-\tau^2}\right), \\ \cos^2\left( \frac{\pi}{4} \frac{(\beta-\beta_0) + 2\alpha + \tan^{-1}\left(\frac{2\tau R}{R^2-\tau^2}\right) - \pi}{\alpha_{thres}+\alpha} \right), & \pi-2\alpha-\tan^{-1}\left(\frac{2\tau R}{R^2-\tau^2}\right) \leq \beta-\beta_0 < \pi + 2\alpha_{thres}, \end{cases}
\end{eqnarray*}
where $\alpha_{thres} = \frac{\beta_{end}-\beta_0 - \pi}{2}$.  For a full scan, i.e., when $\beta_{end}-\beta_0 = 2\pi$, we have $m(\alpha, \beta) = \frac{1}{2}$.

\begin{comment}
One may increase the transaxial field of view \cite{Gullberg_TMI_1986, Gregor_2003} by shifting the detector to one side or by deliberately giving the center of rotation a large offset, i.e.., $|\tau| \gg 0$; see Figure \ref{fig:offsetDetectorReconstruction}.  In this case one must acquire a full scan.  First we let
\begin{eqnarray*}
\delta_{min} &=& \left| R\sin\alpha_{min}-\tau \cos\alpha_{min}\right| \\
\delta_{max} &=& \left| R\sin\alpha_{max}-\tau \cos\alpha_{max}\right|.
\end{eqnarray*}
Then if $\delta_{min} < \delta_{max}$ the weight function is given by
\begin{eqnarray*}
m(\alpha) &=& \begin{cases} \cos^2\left( \frac{\pi}{4}\frac{s-\delta_{min}}{\delta_{min}} \right), & |s| \leq \delta_{min}, \\ 0, & s < -\delta_{min}, \\ 1, & s > \delta_{min} \end{cases}
\end{eqnarray*}
and if $\delta_{max} < \delta_{min}$ the weight function is given by
\begin{eqnarray*}
m(\alpha) &=& \begin{cases} \sin^2\left( \frac{\pi}{4}\frac{s-\delta_{max}}{\delta_{max}} \right), & |s| \leq \delta_{max}, \\ 1, & s < -\delta_{max}, \\ 0, & s > \delta_{max}, \end{cases}
\end{eqnarray*}
where $s = R\sin\alpha-\tau \cos\alpha$ is the standard coordinate transform from curved fan beam to parallel beam coordinates.  Note that these equations are written in parallel beam coordinates and thus it should be apparent that this can be used in all data formats to enlarge the transaxial field of view.  One must only apply the coordinate transformation to that particular coordinate system.  When doing this type of filtering/ reconstruction one needs to pad the measured data with zeros before one applies the ramp filter to simulate a virtual detector that is symmetric about the center of the field of view.

\begin{figure}[h]
\hspace{150 pt}\includegraphics[scale=0.25]{analyticReconAndFiltering/offsetDetectorFOV}
\caption{Increasing the imaging field of view with an offset detector reconstruction.} \label{fig:offsetDetectorReconstruction}
\end{figure}
\end{comment}

\subsection{Modular Beam}

The modular beam data type provides a flexible geometry format to specify systems that do not fall into one of the above coordinate systems.  Since the data is not necessarily given on a regular grid, one can only reconstruction these data sets with iterative techniques.  To use this type of geometry one must specify the location of every source and detector module pair along with the detector module orientation.  A sketch of an example system modeled by the modular beam geometry is shown in Figure \ref{fig:modularBeamSketch}.

%\begin{comment}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{modularBeam}
\end{center}
\caption{Sketch of a geometry built with the modular-beam framework.  The modules here lie on the perimeter of two sides of a rectangle as might exist for a carry-on luggage x-ray scanner.  This sketch was generated with the \textit{sketchSystem()} Python function.  The  magenta box is the reconstruction volume, the gray rectangles are the detector panels, and the red lines trace from the source to each of the four corners of the detector.} \label{fig:modularBeamSketch}
\end{figure}
%\end{comment}

\section{Attenuated Radon Transform}

The Attenuated Radon Transform (ART) and its adjoint in parallel-beam coordinates are given by
\begin{eqnarray*}
P_{\mu}f(s, \varphi, x_3) &=& \int_\mathbb{R} f(s\bm{\theta}^\perp(\varphi) - l\bm{\theta}(\varphi) + x_3\B{e}_3) e^{-\int_0^\infty \mu(s\bm{\theta}^\perp(\varphi) - (l+m)\bm{\theta}(\varphi)) \, dm} \, dl \\
P_{\mu}^*g(\bm{x}) &=& \int_0^{2\pi} g(\bm{x}\cdot\bm{\theta}^\perp(\varphi), \varphi, x_3) e^{-\int_0^\infty \mu(\B{x}-m\bm{\theta}(\varphi)) \, dm} \, d\varphi
\end{eqnarray*}
The object, f, can be reconstructed by the following Filtered Backprojection (FBP) algorithm
\begin{eqnarray*}
f(\bm{x}) &=& \frac{1}{4\pi} \text{Re div} \int_0^{2\pi} \bm{\theta}^\perp(\varphi) e^{\int_0^\infty \mu(\B{x}-m\bm{\theta}(\varphi)) \, dm} \left( e^{-h} H e^{h}g \right)(\bm{x}\cdot\bm{\theta}^\perp(\varphi), \varphi, x_3) \, d\varphi,
\end{eqnarray*}
where $h := \frac{1}{2}\left(I + iH\right) P\mu$, $I$ is the identify operator, and $H$ is the Hilbert Transform.

\section{Projectors for Cylindrically-Symmetric Objects}

The X-ray Transform for cylindrically-symmetric objects is the same as those X-ray Transforms for standard objects, but the volume is assumed to be cylindrically antisymmetric (the left and right sides can be different).  This object model causes the adjoint transform to take a very different form where there is a singularity along the axis of symmetry.  The FBP reconstruction algorithms are the same as those stated in the previous sections.  This is achieved by leveraging the fact that the object is symmetric and thus projections from all angles are the same.

\input{rampFilter.tex}

\end{document}
